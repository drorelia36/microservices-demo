pipeline {
  agent {
    kubernetes {
      yaml """
apiVersion: v1
kind: Pod
spec:
  serviceAccountName: jenkins
  containers:
  - name: tools
    image: alpine:3.20
    command: ["sh", "-c", "cat"]
    tty: true
    volumeMounts:
    - mountPath: "/home/jenkins/agent"
      name: "workspace-volume"

  - name: kubectl
    image: dtzar/helm-kubectl:3.14.4
    command: ["sh", "-c", "cat"]
    tty: true
    volumeMounts:
    - mountPath: "/home/jenkins/agent"
      name: "workspace-volume"

  - name: kaniko
    image: gcr.io/kaniko-project/executor:debug
    command: ["sh", "-c", "cat"]
    tty: true
    volumeMounts:
    - mountPath: "/home/jenkins/agent"
      name: "workspace-volume"
    - mountPath: /secret
      name: gcp-sa
      readOnly: true

  volumes:
  - name: workspace-volume
    emptyDir: {}
  - name: gcp-sa
    secret:
      secretName: gcp-sa-json
"""
    }
  }

  options {
    timestamps()
    disableConcurrentBuilds()
  }

  environment {
    PROJECT_ID = "dror-project-482618"
    REGION     = "europe-west1"
    AR_REPO    = "microservices"
    DEV_NS     = "onlineboutique-dev"
  }

  stages {

    stage("Checkout") {
      steps { checkout scm }
    }

    stage("Info") {
      steps {
        container('tools') {
          sh '''
            set -euo pipefail
            echo "BRANCH_NAME=${BRANCH_NAME}"
            echo "GIT_COMMIT=${GIT_COMMIT}"
          '''
        }
      }
    }

    stage("Lint / Test") {
      steps {
        container('tools') {
          sh '''
            set -euo pipefail
            apk add --no-cache make git bash
            if [ -f Makefile ]; then
              make lint
              make test
            else
              echo "No Makefile â€“ skipping lint/test"
            fi
          '''
        }
      }
    }

    stage("Build & Push service images (main only)") {
      when { branch "main" }
      steps {
        container('kaniko') {
          sh '''
            set -euo pipefail
            export GOOGLE_APPLICATION_CREDENTIALS=/secret/sa.json

            TAG="${GIT_COMMIT:0:7}"
            SERVICES="adservice cartservice checkoutservice currencyservice emailservice \
                      paymentservice productcatalogservice recommendationservice shippingservice frontend"

            find_dockerfile() {
              local svc="$1"
              local ctx="${WORKSPACE}/src/${svc}"

              # 1) standard path
              if [ -f "${ctx}/Dockerfile" ]; then
                echo "${ctx}/Dockerfile"
                return 0
              fi

              # 2) try to find any Dockerfile under service dir (first match)
              local found
              found="$(find "${ctx}" -maxdepth 4 -type f -iname 'Dockerfile' | head -n 1 || true)"
              if [ -n "${found}" ]; then
                echo "${found}"
                return 0
              fi

              return 1
            }

            for SVC in $SERVICES; do
              CTX="${WORKSPACE}/src/${SVC}"
              if [ ! -d "${CTX}" ]; then
                echo "âŒ Service directory not found: ${CTX}"
                exit 1
              fi

              DOCKERFILE="$(find_dockerfile "${SVC}" || true)"
              if [ -z "${DOCKERFILE}" ]; then
                echo "âŒ No Dockerfile found for ${SVC} under ${CTX}"
                echo "   Fix by adding Dockerfile or adjust mapping."
                exit 1
              fi

              # Kaniko requires dockerfile path relative to context OR absolute but within context.
              # We'll pass absolute, but ensure it's under CTX:
              case "${DOCKERFILE}" in
                ${CTX}/*) ;;
                *)
                  echo "âŒ Dockerfile for ${SVC} is outside build context: ${DOCKERFILE}"
                  exit 1
                  ;;
              esac

              IMAGE="${REGION}-docker.pkg.dev/${PROJECT_ID}/${AR_REPO}/${SVC}:${TAG}"
              echo "ðŸš€ Building ${SVC}"
              echo "   Context: ${CTX}"
              echo "   Dockerfile: ${DOCKERFILE}"
              echo "   Destination: ${IMAGE}"

              /kaniko/executor \
                --context "${CTX}" \
                --dockerfile "${DOCKERFILE}" \
                --destination "${IMAGE}" \
                --cache=true
            done
          '''
        }
      }
    }

    stage("Deploy manifests to DEV") {
      when { branch "main" }
      steps {
        container('kubectl') {
          sh '''
            set -euo pipefail
            kubectl -n "${DEV_NS}" apply -k kubernetes-manifests
          '''
        }
      }
    }

    stage("Deploy service images to DEV") {
      when { branch "main" }
      steps {
        container('kubectl') {
          sh '''
            set -euo pipefail
            TAG="${GIT_COMMIT:0:7}"
            SERVICES="adservice cartservice checkoutservice currencyservice emailservice \
                      paymentservice productcatalogservice recommendationservice shippingservice frontend"

            for SVC in $SERVICES; do
              IMAGE="${REGION}-docker.pkg.dev/${PROJECT_ID}/${AR_REPO}/${SVC}:${TAG}"
              echo "ðŸ“¦ Updating ${SVC} -> ${IMAGE}"
              kubectl -n "${DEV_NS}" set image deploy/${SVC} server=${IMAGE}
            done
          '''
        }
      }
    }

    stage("Scale DEV up") {
      when { branch "main" }
      steps {
        container('kubectl') {
          sh '''
            set -euo pipefail
            kubectl scale deploy \
              adservice cartservice checkoutservice currencyservice emailservice \
              paymentservice productcatalogservice recommendationservice shippingservice frontend redis-cart \
              -n "${DEV_NS}" --replicas=1
          '''
        }
      }
    }
  }
}

